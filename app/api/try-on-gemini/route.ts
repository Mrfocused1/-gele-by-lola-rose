import { NextResponse } from 'next/server';
import { v2 as cloudinary } from 'cloudinary';
import path from 'path';
import fs from 'fs';

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function POST(request: Request) {
  try {
    const { userImage, mannequinImagePath } = await request.json();

    if (!userImage) {
      return NextResponse.json({ error: 'Missing user image' }, { status: 400 });
    }

    console.log('[GEMINI IMAGEN 3] Starting virtual try-on...');

    // Upload user's image to Cloudinary
    const uploadResult = await cloudinary.uploader.upload(userImage, {
      folder: 'gele-try-on',
      resource_type: 'image',
      public_id: `try-on-${Date.now()}`,
    });
    const userImageUrl = uploadResult.secure_url;
    console.log('User image uploaded:', userImageUrl);

    // Get mannequin image path and upload to Cloudinary for reference
    const mannequinPath = path.join(process.cwd(), 'public', mannequinImagePath || '/images/mannequins/test-gele-mannequin.jpg');
    console.log('Loading mannequin from:', mannequinPath);

    // Read mannequin image and upload to Cloudinary
    const mannequinBuffer = fs.readFileSync(mannequinPath);
    const mannequinBase64 = `data:image/png;base64,${mannequinBuffer.toString('base64')}`;

    const mannequinUpload = await cloudinary.uploader.upload(mannequinBase64, {
      folder: 'gele-try-on/references',
      resource_type: 'image',
      public_id: `mannequin-ref-${Date.now()}`,
    });
    const mannequinImageUrl = mannequinUpload.secure_url;

    console.log('Calling Gemini Imagen 3 API via REST...');

    // Create detailed prompt describing the desired output
    // Imagen 3 is text-to-image, so we describe what we want to generate
    const prompt = `Professional portrait photograph of a Black woman wearing an elegant, intricately wrapped gele headwrap in traditional African style. The gele should completely cover all hair with a sophisticated tie and fold design. The fabric has vibrant colors and patterns. The woman has a warm, confident smile, looking directly at the camera. Studio lighting with soft shadows, professional photography, high detail, realistic skin tones. The headwrap is the focal point of the image, demonstrating expert wrapping technique with beautiful folds and structure.`;

    // Call Imagen 3 REST API
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict`;

    const imageGenResponse = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': process.env.GEMINI_API_KEY!,
      },
      body: JSON.stringify({
        instances: [
          {
            prompt: prompt,
          }
        ],
        parameters: {
          sampleCount: 1,
          aspectRatio: '1:1',
          safetyFilterLevel: 'block_some',
          personGeneration: 'allow_adult',
        }
      }),
    });

    if (!imageGenResponse.ok) {
      const errorText = await imageGenResponse.text();
      console.error('Imagen 3 API error:', errorText);
      return NextResponse.json({
        error: 'Imagen 3 API request failed',
        details: errorText,
        status: imageGenResponse.status
      }, { status: 500 });
    }

    const imageGenData = await imageGenResponse.json();
    console.log('Imagen 3 response received');

    // Extract generated image from response
    if (!imageGenData.predictions || imageGenData.predictions.length === 0) {
      console.error('No predictions in Imagen response:', imageGenData);
      return NextResponse.json({
        error: 'No image generated by Imagen 3',
        details: imageGenData
      }, { status: 500 });
    }

    const prediction = imageGenData.predictions[0];

    // Imagen 3 returns base64 image in bytesBase64Encoded or imageBytes
    const generatedImageBase64 = prediction.bytesBase64Encoded || prediction.imageBytes;

    if (!generatedImageBase64) {
      console.error('No image data in prediction:', prediction);
      return NextResponse.json({
        error: 'No image data in Imagen 3 response',
        details: prediction
      }, { status: 500 });
    }

    const generatedImageBuffer = Buffer.from(generatedImageBase64, 'base64');
    console.log('Generated image extracted from Imagen 3 response');

    // Upload result to Cloudinary for permanent storage
    const resultUpload = await new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'gele-try-on/results',
          resource_type: 'image',
          public_id: `result-imagen3-${Date.now()}`,
        },
        (error, result) => {
          if (error) reject(error);
          else resolve(result);
        }
      );
      uploadStream.end(generatedImageBuffer);
    });

    console.log('Success! Generated virtual try-on with Gemini Imagen 3');

    return NextResponse.json({
      resultImage: (resultUpload as any).secure_url,
      message: 'Virtual try-on generated with Google Gemini Imagen 3',
    });

  } catch (error: any) {
    console.error('Gemini Imagen 3 API error:', error);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);

    return NextResponse.json({
      error: 'Failed to process image with Imagen 3',
      details: error.message,
      stack: error.stack
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    status: 'API route is working',
    approach: 'Google Gemini 2.5 Flash Image (Nano Banana)',
    config: {
      model: 'gemini-2.5-flash-image',
      features: 'Character-preserving image editing',
      pricing: '~$0.039 per image'
    }
  });
}
